# Convex bodies

Until now, we wrote a very basic impulse based rigid body simulation. However, you probably noticed that it’s lacking a lot of features. The most noticeable is that it only checked collisions with spherical bodies.

In this lesson, we’re going to address this issue. The first few paragraphs will be about developing the Gilbert-Johnson-Keerthi (GJK) algorithm. Which is an elegant and effective algorithm for detecting collisions between convex shapes. Then we’ll discuss how the algorithm can be extended for continuous collision detection with conservative advance.

Also, I want to go ahead and define the term simplex here. A simplex is the simplest geometric shape that can be formed from n+1 points, where n is the number of dimensions. So, in zero dimensions, the simplex is a point. In one dimension, the simplex is a line segment. In two dimensions, it’s a triangle. And in three dimensions it’s a tetrahedron.

## Shapes

### Shape class revisited

There’s a handful of functions that we’ll need to add to the base shape class in order to extend our collision detection to general convex shapes.

```
class Shape
{
public:
	enum class ShapeType
	{
		SHAPE_SPHERE,
		SHAPE_BOX,
		SHAPE_CONVEX
	};
	...
	virtual void Build(const Vec3* pts, const int num) {}
	virtual Vec3 Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) = 0;
	virtual float FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const { return 0; }

protected:
	Vec3 centerOfMass;
};
```

Notice that we’re only overriding the Support function. That’s because the support function gives us a point on the convex shape that is furthest in a particular direction. While the FastestLinearSpeed is a function that is only useful for non-spherical shapes. The FastestLinearSpeed function is used for continuous collision detection. It’s necessary for objects that are ”long”. Since a ”long” object that’s rotating might hit other objects, even though its linear velocity is zero. And for spheres, we don’t care how quickly they rotate; we only care about their linear velocity. But we’ll get more into this when we cover conservative advance later. So, let’s have a look at the Support function for spheres:

```
Vec3 ShapeSphere::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias)
{
	return pos + dir * (radius + bias);
}
```

The dir vector is assumed to be normalized. Also, take note of the bias term. This is used to expand or shrink the apparent size of the shape. Which is necessary for accurately calculating the contact normal. But, we’ll discuss it more in a few paragraphs from now.

### Box shape

The first new shape we’re going to implement is the box shape. Boxes are so common in games, therefore we really need to know how to simulate them. It’ll also help ease us into general convex hulls. We can think of boxes as oriented bounds, or we can think of boxes as convex hulls that have eight points defining the corners. We are going to think of them as the latter, since that’ll be a natural way of moving into general convex hulls.

The class declaration is:

```
class ShapeBox : public Shape
{
public:
	ShapeBox(const Vec3* points, const int num)
	{
		Build(points, num);
	}

	ShapeType GetType() const override { return ShapeType::SHAPE_BOX; }
	Mat3 InertiaTensor() const override;
	Bounds GetBounds(const Vec3& pos, const Quat& orient) const override;
	Bounds GetBounds() const override;
	void Build(const Vec3* pts, const int num) override;
	Vec3 Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) override;
	float FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const override;

	std::vector<Vec3> points;
	Bounds bounds;
};
```
Let’s first have a look at the Build function. This will be where we build the bounds and store the points of the box:

```
void ShapeBox::Build(const Vec3* pts, const int num)
{
	for (int i = 0; i < num; ++i)
	{
		bounds.Expand(pts[i]);
	}

	points.clear();
	points.push_back(Vec3{ bounds.mins.x, bounds.mins.y, bounds.mins.z });
	points.push_back(Vec3{ bounds.maxs .x, bounds.mins.y, bounds.mins.z });
	points.push_back(Vec3{ bounds.mins.x, bounds.maxs.y, bounds.mins.z });
	points.push_back(Vec3{ bounds.mins.x, bounds.mins.y, bounds.maxs.z });

	points.push_back(Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.maxs.z });
	points.push_back(Vec3{ bounds.mins.x, bounds.maxs.y, bounds.maxs.z });
	points.push_back(Vec3{ bounds.maxs.x, bounds.mins.y, bounds.maxs.z });
	points.push_back(Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.mins.z });

	centerOfMass = (bounds.maxs + bounds.mins) * 0.5f;
}
```

The inertia tensor for a box is defined as:

$$
I =
\begin{pmatrix}
1/12 M(h^2 + d^2) & 0 & 0 \\
0 & 1/12 M(w^2 + d^2) & 0 \\
0 & 0 & 1/12 M(h^2 + w^2)
\end{pmatrix}
$$

With h, d, and w the height, depth and width of the box.

However, we can’t gaurantee that the box will be centered about the origin. In order to handle them we need to take advantage of the parallel axis theorem. Recall the definition of the inertia tensor is:

$$ I_{ij} \equiv {\sum_{k} m_k \cdot (\vec{r_k} \cdot \vec{r_k} \cdot \delta_{ij} - x_i \cdot x_j)} $$

Where $\vec{r_i}$ is the distance from the center of mass for the sample point mass, $m_i$. And the tensor form of the parallel axis theorem is:

$$ J_{ij} \equiv I_{ij} + M * (|R|^2\delta_{ij} - R_i R_j) $$

Which gives us the code for the InertiaTensor function:
```

Mat3 ShapeBox::InertiaTensor() const
{
	// Inertia tensor for box centered around zero
	const float dx = bounds.maxs.x - bounds.mins.x;
	const float dy = bounds.maxs.y - bounds.mins.y;
	const float dz = bounds.maxs.z - bounds.mins.z;

	Mat3 tensor;
	tensor.Zero();
	tensor.rows[0][0] = (dy * dy + dz * dz) / 12.0f;
	tensor.rows[1][1] = (dx * dx + dz * dz) / 12.0f;
	tensor.rows[2][2] = (dx * dx + dy * dy) / 12.0f;

	// Now we use the parallel axis theorem to get the inertia
	// tensor for a box that is not centered around the origin

	Vec3 cm;
	cm.x = (bounds.maxs.x + bounds.mins.x) * 0.5f;
	cm.y = (bounds.maxs.y + bounds.mins.y) * 0.5f;
	cm.z = (bounds.maxs.z + bounds.mins.z) * 0.5f;

	// Displacement of the center of mass from origin
	const Vec3 R = Vec3{ 0, 0, 0 } - cm;
	const float R2 = R.GetLengthSqr();

	Mat3 patTensor;
	patTensor.rows[0] = Vec3{ R2 - R.x * R.x, R.x * R.y, R.x * R.z };
	patTensor.rows[1] = Vec3{ R.y * R.x, R2 - R.y * R.y, R.y * R.z };
	patTensor.rows[2] = Vec3{ R.z * R.x, R.z * R.y, R2 - R.z * R.z };

	// Now we need to add the center of mass tensor and the parallel axis
	// theorem tensor together:
	tensor += patTensor;
	return tensor;
}
```

Next let’s have a look at the support function. Remember, the support function only takes in a direction, and returns the vertex on the shape that is furthest in that direction. We can make a pretty simple brute force version of that for our boxes like so:
```
Vec3 ShapeBox::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias)
{
	// Find the point in furthest direction
	Vec3 maxPt = orient.RotatePoint(points[0]) + pos;
	float maxDist = dir.Dot(maxPt);
	for (int i = 1; i < points.size(); i++) {
		const Vec3 pt = orient.RotatePoint(points[i]) + pos;
		const float dist = dir.Dot(pt);

		if (dist > maxDist) {
			maxDist = dist;
			maxPt = pt;
		}
	}

	Vec3 norm = dir;
	norm.Normalize();
	norm *= bias;
	return maxPt + norm;
}
```

Of course we’re going to need the bounds functions for use in the broadphase. This is also a very straightforward method:
```
Bounds ShapeBox::GetBounds(const Vec3& pos, const Quat& orient) const
{
	Vec3 corners[8];
	corners[0] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.mins.z };
	corners[1] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.maxs.z };
	corners[2] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.mins.z };
	corners[3] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.mins.z };

	corners[4] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.maxs.z };
	corners[5] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.mins.z };
	corners[6] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.maxs.z };
	corners[7] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.maxs.z };

	Bounds expandedBounds;
	for (int i = 0; i < 8; ++i) {
		corners[i] = orient.RotatePoint(corners[i]) + pos;
		expandedBounds.Expand(corners[i]);
	}
	return expandedBounds;
}

Bounds ShapeBox::GetBounds() const
{
	return bounds;
}
```

And now the FastestLinearSpeed function. As we mentioned in the previous lesson, this is going to be  used for continuous collision detection. And it takes in a direction and the angular velocity of the object and  returns to us the velocity of the vertex traveling the fastest in that direction.
```
float ShapeBox::FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const
{
	float maxSpeed{ 0 };
	for (int i = 1; i < points.size(); i++) {
		Vec3 r = points[i] - centerOfMass;
		Vec3 linearVelocity = angularVelocity.Cross(r);
		float speed = dir.Dot(linearVelocity);
		if (speed > maxSpeed) {
			maxSpeed = speed;
		}
	}
	return maxSpeed;
}
```

### Convex hull

If we want to start modeling bodies that are more complicated than spheres and boxes then we need to figure out how to collide general convex shapes. Technically a convex hull is the intersection of a set of infinite half spaces. But for our needs it’ll just be an array of points. And it’s going to be pretty easy to add this shape to the code, since we already have a base shape class:

`Shape.h`
```
class ShapeConvex : public Shape {
public:
	explicit ShapeConvex(const Vec3* pts, const int num) {
		Build(pts, num);
	}

	void Build(const Vec3* pts, const int num) override;
	Vec3 Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) const override;
	Mat3 InertiaTensor() const override;
	float FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const override;

	Bounds GetBounds(const Vec3& pos, const Quat& orient) const override;
	Bounds GetBounds() const override;
	ShapeType GetType() const override { return ShapeType::SHAPE_CONVEX; }

	std::vector<Vec3> points;
	Bounds bounds;
	Mat3 inertiaTensor;
};
```

`Shape.cpp`
```
Bounds ShapeConvex::GetBounds(const Vec3& pos, const Quat& orient) const
{
	Vec3 corners[8];
	corners[0] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.mins.z };
	corners[1] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.maxs.z };
	corners[2] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.mins.z };
	corners[3] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.mins.z };

	corners[4] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.maxs.z };
	corners[5] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.mins.z };
	corners[6] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.maxs.z };
	corners[7] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.maxs.z };

	Bounds expandedBounds;
	for (int i = 0; i < 8; ++i) {
		corners[i] = orient.RotatePoint(corners[i]) + pos;
		expandedBounds.Expand(corners[i]);
	}
	return expandedBounds;
}

Bounds ShapeConvex::GetBounds() const
{
	return bounds;
}

Mat3 ShapeConvex::InertiaTensor() const
{
	return inertiaTensor;
}

Vec3 ShapeConvex::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) const
{
	// Empty for now
}

float ShapeConvex::FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const
{
	float maxSpeed{ 0 };
	for (int i = 1; i < points.size(); i++) {
		Vec3 r = points[i] - centerOfMass;
		Vec3 linearVelocity = angularVelocity.Cross(r);
		float speed = dir.Dot(linearVelocity);
		if (speed > maxSpeed) {
			maxSpeed = speed;
		}
	}
	return maxSpeed;
}
```

Now, you might think that the Build function for this class should be pretty simple. After all, we’re just going to pass in an array of points and store an array of points, so can’t we just copy it and that’s it? Unfortunately, it’s not that simple. Because we also need to construct the inertia tensor. And, we need to be certain that the only points we store, are points that are on the surface of the convex hull. So how do we do all this?

Well, we basically have to slowly build up connections of the points. If any points are found to be inside the convex hull, then they’re discarded. We can do this by building a simplex (tetrahedron) and then expanding it out to include all the points that are outside of it. To build the tetrahedron we take four basic steps:
1. Find a point that is the furthest in a particular direction (later we will call this a support point)
2. Find another point that is furthest in the opposite direction of the point from step 1
3. Find a third point that is furthest from the axis of the points formed from 1 & 2
4. Then we find the point that is furthest from the plane formed from the previous points
5. Finally, we build the “connections” of those points. But really, we’re just recording triangle indices.

In order to achieve that, we'll create a `ShapeUtils.h` function collection:

`ShapeUtils.h`
```
#pragma once
#include "code/Math/Vector.h"
#include <vector>

struct Tri {
	int a;
	int b;
	int c;
};

struct Edge {
	int a;
	int b;

	bool operator == (const Edge& rhs) const {
		return ((a == rhs.a && b == rhs.b) || (a == rhs.b && b == rhs.a));
	}
};

int FindPointFurthestInDir(const Vec3* pts, const int num, const Vec3& dir);

float DistanceFromLine(const Vec3& a, const Vec3& b, const Vec3& pt);

Vec3 FindPointFurthestFromLine(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB);

float DistanceFromTriangle(const Vec3& a, const Vec3& b, const Vec3& c, const Vec3& pt);

Vec3 FindPointFurthestFromTriangle(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB, const Vec3& ptC);

void BuildTetrahedron(const Vec3* verts, const int num, std::vector<Vec3>& hullPts, std::vector<Tri>& hullTris);

void RemoveInternalPoints(const std::vector<Vec3>& hullPoints, const std::vector<Tri>& hullTris, std::vector<Vec3>& checkPts);

bool IsEdgeUnique(const std::vector<Tri>& tris, const std::vector<int>& facingTris, const int ignoreTri, const Edge& edge);

void AddPoint(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const Vec3& pt);

void RemoveUnreferencedVerts(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris);

void ExpandConvexHull(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const std::vector<Vec3>& verts);

bool IsExternal(const std::vector<Vec3>& pts, const std::vector<Tri>& tris, const Vec3& pt);

void BuildConvexHull(
	const std::vector<Vec3>& verts,
	std::vector<Vec3>& hullPts,
	std::vector<Tri>& hullTris
);
```

`ShapeUtils.cpp`
```
#pragma once
#include "ShapeUtils.h"

int FindPointFurthestInDir(const Vec3* pts, const int num, const Vec3& dir)
{
	int maxIndex = 0;
	float maxDist = dir.Dot(pts[0]);
	for (int i = 1; i < num; i++) {
		float dist = dir.Dot(pts[i]);
		if (dist > maxDist) {
			maxDist = dist;
			maxIndex = i;
		}
	}
	return maxIndex;
}

float DistanceFromLine(const Vec3& a, const Vec3& b, const Vec3& pt)
{
	Vec3 ab = b - a;
	ab.Normalize();

	Vec3 ray = pt - a;
	Vec3 projectionOnAB = ab * ray.Dot(ab);
	Vec3 perpindicular = ray - projectionOnAB;
	return perpindicular.GetMagnitude();
}

Vec3 FindPointFurthestFromLine(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB)
{
	int maxIdx = 0;
	float maxDist = DistanceFromLine(ptA, ptB, pts[0]);
	for (int i = 1; i < num; i++) {
		float dist = DistanceFromLine(ptA, ptB, pts[i]);
		if (dist > maxDist) {
			maxDist = dist;
			maxIdx = i;
		}
	}
	return pts[maxIdx];
}

float DistanceFromTriangle(const Vec3& a, const Vec3& b, const Vec3& c, const Vec3& pt)
{
	Vec3 ab = b - a;
	Vec3 ac = c - a;
	Vec3 normal = ab.Cross(ac);
	normal.Normalize();

	Vec3 ray = pt - a;
	float dist = ray.Dot(normal);
	return dist;
}

Vec3 FindPointFurthestFromTriangle(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB, const Vec3& ptC)
{
	int maxIdx = 0;
	float maxDist = DistanceFromTriangle(ptA, ptB, ptC, pts[0]);
	for (int i = 1; i < num; i++) {
		float dist = DistanceFromTriangle(ptA, ptB, ptC, pts[i]);
		if (dist * dist > maxDist * maxDist) {
			maxDist = dist;
			maxIdx = i;
		}
	}
	return pts[maxIdx];
}

struct Tri {
	int a;
	int b;
	int c;
};

struct Edge {
	int a;
	int b;

	bool operator == (const Edge& rhs) const {
		return ((a == rhs.a && b == rhs.b) || (a == rhs.b && b == rhs.a));
	}
};

void BuildTetrahedron(const Vec3* verts, const int num, std::vector<Vec3>& hullPts, std::vector<Tri>& hullTris) {
	hullPts.clear();
	hullTris.clear();

	Vec3 points[4];

	int idx = FindPointFurthestInDir(verts, num, Vec3(1, 0, 0));
	points[0] = verts[idx];
	idx = FindPointFurthestInDir(verts, num, points[0] * -1.0f);
	points[1] = verts[idx];
	points[2] = FindPointFurthestFromLine(verts, num, points[0], points[1]);
	points[3] = FindPointFurthestFromTriangle(verts, num, points[0], points[1], points[2]);

	// This is important for making sure the ordering is CCW for all faces.
	float dist = DistanceFromTriangle(points[0], points[1], points[2], points[3]);
	if (dist > 0.0f) {
		std::swap(points[0], points[1]);
	}

	// Build the tetrahedron
	hullPts.push_back(points[0]);
	hullPts.push_back(points[1]);
	hullPts.push_back(points[2]);
	hullPts.push_back(points[3]);

	hullTris.push_back(Tri{ 0, 1, 2 });
	hullTris.push_back(Tri{ 0, 2, 3 });
	hullTris.push_back(Tri{ 2, 1, 3 });
	hullTris.push_back(Tri{ 1, 0, 3 });
}
```
Note that we need to make sure that every face of the tetrahedron is in counterclockwise order (CCW), since we’ll use that to calculate the normals of each face, and our convex shapes have outward facing normals.

So, now that we have the most basic convex hull possible (a tetrahedron). We need to expand it out to include all the other points that define the surface of the shape. Here’s an outline of the steps that we need to perform to expand the tetrahedron to the convex hull:
1. Remove any internal points. There may be some points that are already inside the tetrahedron, so we need to discard them, since we only want the points that are on the surface of the convex hull.
2. Then we choose any point that is still external to the hull, and find the point furthest in that direction.
3. Then we find all the triangles that face this point and discard them.
4. Find the dangling edges, and use them to create new triangles.
5. Go back to step 1 and repeat until there are no external points.
6. Remove any points that are not referenced by any triangles.

Here is the function to to that:

`ShapeUtils.cpp`
```
void ExpandConvexHull(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const std::vector<Vec3>& verts)
{
	std::vector< Vec3 > externalVerts = verts;
	RemoveInternalPoints(hullPoints, hullTris, externalVerts);

	while (externalVerts.size() > 0) {
		int ptIdx = FindPointFurthestInDir(externalVerts.data(), (int)externalVerts.size(), externalVerts[0]);

		Vec3 pt = externalVerts[ptIdx];

		// Remove this element
		externalVerts.erase(externalVerts.begin() + ptIdx);

		AddPoint(hullPoints, hullTris, pt);

		RemoveInternalPoints(hullPoints, hullTris, externalVerts);
	}

	RemoveUnreferencedVerts(hullPoints, hullTris);
}
```

To execute this function, we need other functions. Let’s start with the RemoveInternalPoints. This is pretty brute force, we will just iterate through the “externalVerts” list and check if any of them are inside the current convex hull. If a point is inside the hull, then we will remove it from the list:

`ShapeUtils.cpp`
```
void RemoveInternalPoints(const std::vector<Vec3>& hullPoints, const std::vector<Tri>& hullTris, std::vector<Vec3>& checkPts)
{
	for (int i = 0; i < checkPts.size(); i++) {
		const Vec3& pt = checkPts[i];

		bool isExternal = false;
		for (int t = 0; t < hullTris.size(); t++) {
			const Tri& tri = hullTris[t];
			const Vec3& a = hullPoints[tri.a];
			const Vec3& b = hullPoints[tri.b];
			const Vec3& c = hullPoints[tri.c];

			// If the point is in front of any triangle then it's external
			float dist = DistanceFromTriangle(a, b, c, pt);
			if (dist > 0.0f) {
				isExternal = true;
				break;
			}
		}

		// If it's not external, then it's inside the polyhedron and should be removed
		if (!isExternal) {
			checkPts.erase(checkPts.begin() + i);
			i--;
		}
	}

	// Also remove any points that are just a little too close to the hull points
	for (int i = 0; i < checkPts.size(); i++) {
		const Vec3& pt = checkPts[i];

		bool isTooClose = false;
		for (int j = 0; j < hullPoints.size(); j++) {
			Vec3 hullPt = hullPoints[j];
			Vec3 ray = hullPt - pt;
			// 1cm is too close
			if (ray.GetLengthSqr() < 0.01f * 0.01f) {
				isTooClose = true;
				break;
			}
		}

		if (isTooClose) {
			checkPts.erase(checkPts.begin() + i);
			i--;
		}
	}
}
```

Now, let’s talk about the AddPoint function. By all means this will be the most complicated part of this section. This is where we will have to loop over all triangles and determine if the point is on the positive side of the triangle, and if it is, delete the triangle. Then once all triangles are deleted, find the dangling edges and build new triangles:
```
bool IsEdgeUnique(const std::vector<Tri>& tris, const std::vector<int>& facingTris, const int ignoreTri, const Edge& edge)
{
	for (int i = 0; i < facingTris.size(); i++) {
		const int triIdx = facingTris[i];
		if (ignoreTri == triIdx) {
			continue;
		}

		const Tri& tri = tris[triIdx];

		Edge edges[3];
		edges[0].a = tri.a;
		edges[0].b = tri.b;

		edges[1].a = tri.b;
		edges[1].b = tri.c;

		edges[2].a = tri.c;
		edges[2].b = tri.a;

		for (int e = 0; e < 3; e++) {
			if (edge == edges[e]) {
				return false;
			}
		}
	}
	return true;
}

void AddPoint(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const Vec3& pt)
{
	// This point is outside
	// Now we need to remove old triangles and build new ones

	// Find all the triangles that face this point
	std::vector< int > facingTris;
	for (int i = (int)hullTris.size() - 1; i >= 0; i--) {
		const Tri& tri = hullTris[i];

		const Vec3& a = hullPoints[tri.a];
		const Vec3& b = hullPoints[tri.b];
		const Vec3& c = hullPoints[tri.c];

		const float dist = DistanceFromTriangle(a, b, c, pt);
		if (dist > 0.0f) {
			facingTris.push_back(i);
		}
	}

	// Now find all edges that are unique to the tris, these will be the edges that form the new triangles
	std::vector<Edge> uniqueEdges;
	for (int i = 0; i < facingTris.size(); i++) {
		const int triIdx = facingTris[i];
		const Tri& tri = hullTris[triIdx];

		Edge edges[3];
		edges[0].a = tri.a;
		edges[0].b = tri.b;

		edges[1].a = tri.b;
		edges[1].b = tri.c;

		edges[2].a = tri.c;
		edges[2].b = tri.a;

		for (int e = 0; e < 3; e++) {
			if (IsEdgeUnique(hullTris, facingTris, triIdx, edges[e])) {
				uniqueEdges.push_back(edges[e]);
			}
		}
	}

	// Now remove the old facing tris
	for (int i = 0; i < facingTris.size(); i++) {
		hullTris.erase(hullTris.begin() + facingTris[i]);
	}

	// Now add the new point
	hullPoints.push_back(pt);
	const int newPtIdx = (int)hullPoints.size() - 1;

	// Now add triangles for each unique edge
	for (int i = 0; i < uniqueEdges.size(); i++) {
		const Edge& edge = uniqueEdges[i];

		Tri tri;
		tri.a = edge.a;
		tri.b = edge.b;
		tri.c = newPtIdx;
		hullTris.push_back(tri);
	}
}
```

Finally, let’s talk about the RemoveUnreferencedVerts function. You may have noticed that when we removed triangles from the convex hull, that we didn’t remove the points that were referenced by the triangle. This is a really simple function, we only need to loop over each point and then check if it’s referenced by any triangles, if it isn’t, then we remove it.
```
void RemoveUnreferencedVerts(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris)
{
	for (int i = 0; i < hullPoints.size(); i++) {

		bool isUsed = false;
		for (int j = 0; j < hullTris.size(); j++) {
			const Tri& tri = hullTris[j];

			if (tri.a == i || tri.b == i || tri.c == i) {
				isUsed = true;
				break;
			}
		}

		if (isUsed) {
			continue;
		}

		for (int j = 0; j < hullTris.size(); j++) {
			Tri& tri = hullTris[j];
			if (tri.a > i) {
				tri.a--;
			}
			if (tri.b > i) {
				tri.b--;
			}
			if (tri.c > i) {
				tri.c--;
			}
		}

		hullPoints.erase(hullPoints.begin() + i);
		i--;
	}
}
```

We can finally build the convex hull:
```
void BuildConvexHull(
	const std::vector<Vec3>& verts,
	std::vector<Vec3>& hullPts,
	std::vector<Tri>& hullTris
) {
	if (verts.size() < 4) {
		return;
	}

	// Build a tetrahedron
	BuildTetrahedron(verts.data(), (int)verts.size(), hullPts, hullTris);

	ExpandConvexHull(hullPts, hullTris, verts);
}
```

We’ve managed to take in a set of vertices, removed any vertices that are not on the surface of the convex hull, and built the list of triangles that composes the surface of the convex hull. The only thing we need to do now is build the inertia tensor for the shape. However, this is large enough of a topic, that we’ll do it in the next paragraph.

### Inertia tensor for convex hull

There’s a handful of ways we could go about calculating the inertia tensor for a convex hull. What we will do is perform a 3D integration over the bounds of the convex hull and if the sample point is outside the hull, we ignore it, but if it’s inside the hull then we treat it as a point mass and accumulate its moment of inertia. Recall that the definition of moment of inertia is:

$$ I_{ij} \equiv {\sum_{k} m_k \cdot (\vec{r_k} \cdot \vec{r_k} \cdot \delta_{ij} - x_i \cdot x_j)} $$

Where $\vec{r_i}$ is the distance from the center of mass for the sample point mass, $m_i$.

So, the first thing we need to do is calculate the center of mass. This will actually be a very similar algorithm to the inertia tensor, we’ll integrate over the bounds and only accumulate the sample points that are inside the convex hull. Recall that the center of mass is:

$$ x_{cm} = \frac {\sum_{i} x_i * m_i} {\sum_{i} m_i} $$

Let’s calculate the center of mass of the convex hull, then the inertia tensor:

`ShapeUtils.h`
```
bool IsExternal(const std::vector< Vec3 >& pts, const std::vector<Tri>& tris, const Vec3& pt)
{
	bool isExternal = false;
	for (int t = 0; t < tris.size(); t++) {
		const Tri& tri = tris[t];
		const Vec3& a = pts[tri.a];
		const Vec3& b = pts[tri.b];
		const Vec3& c = pts[tri.c];

		// If the point is in front of any triangle then it's external
		float dist = DistanceFromTriangle(a, b, c, pt);
		if (dist > 0.0f) {
			isExternal = true;
			break;
		}
	}

	return isExternal;
}
```

`Shape.h`
```
class ShapeConvex : public Shape
{
public:
	...

private:
	Vec3 CalculateCenterOfMass(const std::vector< Vec3 >& pts, const std::vector<Tri>& tris);
	Mat3 CalculateInertiaTensor(const std::vector< Vec3 >& pts, const std::vector<Tri>& tris, const Vec3& cm);
};
```

`Shape.cpp`
```
Vec3 ShapeConvex::CalculateCenterOfMass(const std::vector<Vec3>& pts, const std::vector<Tri>& tris)
{
	const int numSamples = 100;

	Bounds bounds;
	bounds.Expand(pts.data(), pts.size());

	Vec3 cm(0.0f);
	const float dx = bounds.WidthX() / (float)numSamples;
	const float dy = bounds.WidthY() / (float)numSamples;
	const float dz = bounds.WidthZ() / (float)numSamples;

	int sampleCount = 0;
	for (float x = bounds.mins.x; x < bounds.maxs.x; x += dx) {
		for (float y = bounds.mins.y; y < bounds.maxs.y; y += dy) {
			for (float z = bounds.mins.z; z < bounds.maxs.z; z += dz) {
				Vec3 pt(x, y, z);

				if (IsExternal(pts, tris, pt)) {
					continue;
				}

				cm += pt;
				sampleCount++;
			}
		}
	}

	cm /= (float)sampleCount;
	return cm;
}

Mat3 ShapeConvex::CalculateInertiaTensor(const std::vector<Vec3>& pts, const std::vector<Tri>& tris, const Vec3& cm)
{
	const int numSamples = 100;

	Bounds bounds;
	bounds.Expand(pts.data(), (int)pts.size());

	Mat3 tensor;
	tensor.Zero();

	const float dx = bounds.WidthX() / (float)numSamples;
	const float dy = bounds.WidthY() / (float)numSamples;
	const float dz = bounds.WidthZ() / (float)numSamples;

	int sampleCount = 0;
	for (float x = bounds.mins.x; x < bounds.maxs.x; x += dx) {
		for (float y = bounds.mins.y; y < bounds.maxs.y; y += dy) {
			for (float z = bounds.mins.z; z < bounds.maxs.z; z += dz) {
				Vec3 pt(x, y, z);

				if (IsExternal(pts, tris, pt)) {
					continue;
				}

				// Get the point relative to the center of mass
				pt -= cm;

				tensor.rows[0][0] += pt.y * pt.y + pt.z * pt.z;
				tensor.rows[1][1] += pt.z * pt.z + pt.x * pt.x;
				tensor.rows[2][2] += pt.x * pt.x + pt.y * pt.y;

				tensor.rows[0][1] += -1.0f * pt.x * pt.y;
				tensor.rows[0][2] += -1.0f * pt.x * pt.z;
				tensor.rows[1][2] += -1.0f * pt.y * pt.z;

				tensor.rows[1][0] += -1.0f * pt.x * pt.y;
				tensor.rows[2][0] += -1.0f * pt.x * pt.z;
				tensor.rows[2][1] += -1.0f * pt.y * pt.z;

				sampleCount++;
			}
		}
	}

	tensor *= 1.0f / (float)sampleCount;
	return tensor;
}
```

### Finalizing the convex hull

Now that we have a means of constructing a convex hull from a set of points and then calculating the center of mass and inertia tensor, we can finally put it all together. We’ve already done all the hard work. So the Build function for the convex shape turns into:

`Shape.cpp`
```
void ShapeConvex::Build(const Vec3* pts, const int num)
{
	points.clear();
	points.reserve(num);
	for (int i = 0; i < num; i++) {
		points.push_back(pts[i]);
	}

	// Expand into a convex hull
	std::vector<Vec3> hullPoints;
	std::vector<Tri> hullTriangles;
	BuildConvexHull(points, hullPoints, hullTriangles);
	points = hullPoints;

	// Expand the bounds
	bounds.Clear();
	bounds.Expand(points.data(), points.size());

	centerOfMass = CalculateCenterOfMass(hullPoints, hullTriangles);

	inertiaTensor = CalculateInertiaTensor(hullPoints, hullTriangles, centerOfMass);
}
```

Now we will replace the ground from the last lesson with a flat box shape, and then add some dynamic bodies. But first let’s go ahead and define the geometry for some new shapes we’ll be using.

Do not forget to uncomment the code in `Model::BuildFromShape(const Shape* shape)` (`model.cpp` file), so that the box and convex hull can be properly imported.

`Scene.cpp`
```
/*
========================================================================================================

Models

========================================================================================================
*/

static const float w = 50;
static const float h = 25;

Vec3 g_boxGround[] = {
	Vec3(-w,-h, 0),
	Vec3(w,-h, 0),
	Vec3(-w, h, 0),
	Vec3(w, h, 0),

	Vec3(-w,-h,-1),
	Vec3(w,-h,-1),
	Vec3(-w, h,-1),
	Vec3(w, h,-1),
};

Vec3 g_boxWall0[] = {
	Vec3(-1,-h, 0),
	Vec3(1,-h, 0),
	Vec3(-1, h, 0),
	Vec3(1, h, 0),

	Vec3(-1,-h, 5),
	Vec3(1,-h, 5),
	Vec3(-1, h, 5),
	Vec3(1, h, 5),
};

Vec3 g_boxWall1[] = {
	Vec3(-w,-1, 0),
	Vec3(w,-1, 0),
	Vec3(-w, 1, 0),
	Vec3(w, 1, 0),

	Vec3(-w,-1, 5),
	Vec3(w,-1, 5),
	Vec3(-w, 1, 5),
	Vec3(w, 1, 5),
};

Vec3 g_boxUnit[] = {
	Vec3(-1,-1,-1),
	Vec3(1,-1,-1),
	Vec3(-1, 1,-1),
	Vec3(1, 1,-1),

	Vec3(-1,-1, 1),
	Vec3(1,-1, 1),
	Vec3(-1, 1, 1),
	Vec3(1, 1, 1),
};

static const float t = 0.25f;
Vec3 g_boxSmall[] = {
	Vec3(-t,-t,-t),
	Vec3(t,-t,-t),
	Vec3(-t, t,-t),
	Vec3(t, t,-t),

	Vec3(-t,-t, t),
	Vec3(t,-t, t),
	Vec3(-t, t, t),
	Vec3(t, t, t),
};

static const float l = 3.0f;
Vec3 g_boxBeam[] = {
	Vec3(-l,-t,-t),
	Vec3(l,-t,-t),
	Vec3(-l, t,-t),
	Vec3(l, t,-t),

	Vec3(-l,-t, t),
	Vec3(l,-t, t),
	Vec3(-l, t, t),
	Vec3(l, t, t),
};

Vec3 g_boxPlatform[] = {
	Vec3(-l,-l,-t),
	Vec3(l,-l,-t),
	Vec3(-l, l,-t),
	Vec3(l, l,-t),

	Vec3(-l,-l, t),
	Vec3(l,-l, t),
	Vec3(-l, l, t),
	Vec3(l, l, t),
};

static const float t2 = 0.25f;
static const float w2 = t2 * 2.0f;
static const float h3 = t2 * 4.0f;
Vec3 g_boxBody[] = {
	Vec3(-t2,-w2,-h3),
	Vec3(t2,-w2,-h3),
	Vec3(-t2, w2,-h3),
	Vec3(t2, w2,-h3),

	Vec3(-t2,-w2, h3),
	Vec3(t2,-w2, h3),
	Vec3(-t2, w2, h3),
	Vec3(t2, w2, h3),
};

static const float h2 = 0.25f;
Vec3 g_boxLimb[] = {
	Vec3(-h3,-h2,-h2),
	Vec3(h3,-h2,-h2),
	Vec3(-h3, h2,-h2),
	Vec3(h3, h2,-h2),

	Vec3(-h3,-h2, h2),
	Vec3(h3,-h2, h2),
	Vec3(-h3, h2, h2),
	Vec3(h3, h2, h2),
};

Vec3 g_boxHead[] = {
	Vec3(-h2,-h2,-h2),
	Vec3(h2,-h2,-h2),
	Vec3(-h2, h2,-h2),
	Vec3(h2, h2,-h2),

	Vec3(-h2,-h2, h2),
	Vec3(h2,-h2, h2),
	Vec3(-h2, h2, h2),
	Vec3(h2, h2, h2),
};

Vec3 g_diamond[7 * 8];
void FillDiamond() {
	Vec3 pts[4 + 4];
	pts[0] = Vec3(0.1f, 0, -1);
	pts[1] = Vec3(1, 0, 0);
	pts[2] = Vec3(1, 0, 0.1f);
	pts[3] = Vec3(0.4f, 0, 0.4f);

	const float pi = acosf(-1.0f);
	const Quat quatHalf(Vec3(0, 0, 1), 2.0f * pi * 0.125f * 0.5f);
	pts[4] = Vec3(0.8f, 0, 0.3f);
	pts[4] = quatHalf.RotatePoint(pts[4]);
	pts[5] = quatHalf.RotatePoint(pts[1]);
	pts[6] = quatHalf.RotatePoint(pts[2]);

	const Quat quat(Vec3(0, 0, 1), 2.0f * pi * 0.125f);
	int idx = 0;
	for (int i = 0; i < 7; i++) {
		g_diamond[idx] = pts[i];
		idx++;
	}

	Quat quatAccumulator;
	for (int i = 1; i < 8; i++) {
		quatAccumulator = quatAccumulator * quat;
		for (int pt = 0; pt < 7; pt++) {
			g_diamond[idx] = quatAccumulator.RotatePoint(pts[pt]);
			idx++;
		}
	}
}

void AddStandardSandBox(std::vector<Body>& bodies) {
	Body body;

	body.position = Vec3(0, 0, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.5f;
	body.shape = new ShapeBox(g_boxGround, sizeof(g_boxGround) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(50, 0, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall0, sizeof(g_boxWall0) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(-50, 0, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall0, sizeof(g_boxWall0) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(0, 25, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall1, sizeof(g_boxWall1) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(0, -25, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall1, sizeof(g_boxWall1) / sizeof(Vec3));
	bodies.push_back(body);
}

...

/*
====================================================
Scene::Initialize
====================================================
*/
void Scene::Initialize() {
	Body body;

	body.position = Vec3(10, 0, 3);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity = Vec3(-100, 0, 0);
	body.angularVelocity = Vec3(0.0f, 0.0f, 0.0f);
	body.inverseMass = 1.0f;
	body.elasticity = 0.5f;
	body.friction = 0.5f;
	body.shape = new ShapeSphere(0.5f);
	bodies.push_back(body);

	AddStandardSandBox(bodies);
}
```